package parquet

import (
	"fmt"
	"io"
	"io/ioutil"

	"github.com/kostya-sh/parquet-go/parquetformat"
)

// TODO: add other commons methods
type ColumnChunkReader interface {
	Next() bool
	NextPage() bool
	Err() error
	// TODO: use smaller type, maybe byte?
	Repetition() int
	// TODO: use smaller type, maybe byte?
	Definition() int
	Value() interface{}
}

// TODO: shorter name?
type BooleanColumnChunkReader struct {
	r              io.ReadSeeker
	dataPageOffset int64
	err            error
	pageHeader     *parquetformat.PageHeader
	pageData       []byte
}

func NewBooleanColumnChunkReader(r io.ReadSeeker, schema *parquetformat.SchemaElement, chunk *parquetformat.ColumnChunk) (*BooleanColumnChunkReader, error) {
	if chunk.FilePath != nil {
		return nil, fmt.Errorf("data in another file: '%s'", *chunk.FilePath)
	}

	// chunk.FileOffset is useless
	// see https://issues.apache.org/jira/browse/PARQUET-291
	meta := chunk.MetaData
	if meta == nil {
		return nil, fmt.Errorf("missing ColumnMetaData")
	}

	if meta.Type != parquetformat.Type_BOOLEAN {
		return nil, fmt.Errorf("wrong type, expected BOOLEAN was %s", meta.Type)
	}

	if schema.RepetitionType == nil {
		return nil, fmt.Errorf("nil RepetitionType")
	}
	if *schema.RepetitionType != parquetformat.FieldRepetitionType_REQUIRED {
		// just to make it work for now
		panic("nyi")
	}

	// uncompress
	if meta.Codec != parquetformat.CompressionCodec_UNCOMPRESSED {
		return nil, fmt.Errorf("unsupported compression codec: %s", meta.Codec)
	}

	cr := BooleanColumnChunkReader{
		r:              r,
		dataPageOffset: meta.DataPageOffset,
	}

	return &cr, nil
}

// IsAtStartOfPage returns true if the reader is positioned at the first value of a page.
func (cr *BooleanColumnChunkReader) IsAtStartOfPage() bool {
	return true
}

// PageHeader returns page header of the current page.
func (cr *BooleanColumnChunkReader) PageHeader() *parquetformat.PageHeader {
	return cr.pageHeader
}

// Next advances the reader to the next value, which then will be available
// through Boolean method. It returns false when the reading stops, either by
// reaching the end of the input or an error.
func (cr *BooleanColumnChunkReader) Next() bool {
	var err error

	if cr.err != nil {
		return false
	}
	if _, err := cr.r.Seek(cr.dataPageOffset, 0); err != nil {
		cr.err = err
		return false
	}
	ph := parquetformat.PageHeader{}
	if err := ph.Read(cr.r); err != nil {
		cr.err = err
		return false
	}
	if ph.Type != parquetformat.PageType_DATA_PAGE {
		cr.err = fmt.Errorf("DATA_PAGE type expected, but was %s", ph.Type)
		return false
	}
	if ph.DataPageHeader == nil {
		cr.err = fmt.Errorf("null DataPageHeader in %+v", ph)
		return false
	}
	cr.pageHeader = &ph

	dph := ph.DataPageHeader

	if dph.Encoding != parquetformat.Encoding_PLAIN {
		cr.err = fmt.Errorf("Unsupported encoding %s for BOOLEAN type", dph.Encoding)
		return false
	}

	pageReader := io.LimitReader(cr.r, int64(ph.CompressedPageSize))
	cr.pageData, err = ioutil.ReadAll(pageReader)
	if err != nil {
		cr.err = err
		return false
	}

	// TODO: decode

	return false
}

// Skip behaves as Next but it may skip decoding the current value.
// TODO: think about use case
func (cr *BooleanColumnChunkReader) Skip() bool {
	return false
}

// NextPage advances the reader to the first value of the next page. It behaves as Next.
func (cr *BooleanColumnChunkReader) NextPage() bool {
	return false
}

// Repetition returns repetition level of the most recent value generated by a call to Next or NextPage.
func (cr *BooleanColumnChunkReader) Repetition() int {
	return 0
}

// Definition returns definition level of the most recent value generated by a call to Next or NextPage.
func (cr *BooleanColumnChunkReader) Definition() int {
	return 0
}

// Boolean returns the most recent value generated by a call to Next or NextPage
func (cr *BooleanColumnChunkReader) Boolean() bool {
	return true
}

// Value() = Boolean()
func (cr *BooleanColumnChunkReader) Value() interface{} {
	return cr.Boolean()
}

// Err returns the first non-EOF error that was encountered by the reader.
func (cr *BooleanColumnChunkReader) Err() error {
	return cr.err
}

// temporary, just for testing at the moment
func getColumnReader(r io.ReadSeeker, c int32) error {
	meta, err := ReadFileMetaData(r)
	if err != nil {
		return err
	}

	// just the first row group for now
	chunk := meta.RowGroups[0].Columns[c]
	if chunk.FilePath != nil {
		panic("nyi")
	}

	// chunk.FileOffset is useless
	// see https://issues.apache.org/jira/browse/PARQUET-291
	cm := chunk.MetaData
	if cm == nil {
		return fmt.Errorf("no ColumnMetaData")
	}

	// read page 1
	if _, err = r.Seek(cm.DataPageOffset, 0); err != nil {
		return err
	}
	ph := parquetformat.PageHeader{}
	if err = ph.Read(r); err != nil {
		return err
	}
	if ph.Type != parquetformat.PageType_DATA_PAGE {
		return fmt.Errorf("DATA_PAGE type expected, but was %s", ph.Type)
	}
	if ph.DataPageHeader == nil {
		return fmt.Errorf("null DataPageHeader")
	}
	dph := ph.DataPageHeader

	fmt.Printf("%+v\n%+v\n", ph, dph)

	// uncompress
	if cm.Codec != parquetformat.CompressionCodec_UNCOMPRESSED {
		panic("nyi")
	}
	//pageReader := io.LimitReader(r, int64(ph.CompressedPageSize))

	// decode
	if cm.Type == parquetformat.Type_BOOLEAN {
		se := meta.Schema[c+1] // TODO: find Schema by path
		if se.RepetitionType == nil {
			return fmt.Errorf("nil RepetitionType")
		}
		if *se.RepetitionType != parquetformat.FieldRepetitionType_REQUIRED {
			// just to make it work for now
			panic("nyi")
		}
		if dph.Encoding != parquetformat.Encoding_PLAIN {
			return fmt.Errorf("Unsupported encoding %s for type %s",
				dph.Encoding, cm.Type)
		}

		// TODO: do something
	} else {
		panic("nyi")
	}

	return nil
}
